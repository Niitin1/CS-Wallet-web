import {Component, OnInit, Output, EventEmitter} from '@angular/core';
import {DataService} from "../data.service";
import {Md5} from "ts-md5";
import {sprintf} from "sprintf-js";
import {GuidGenerator} from "../utils/GuidGenerator";
import {environment} from "../../environments/environment";
import {Utils} from "../utils/Utils";
import {HttpResponseData} from "../domain/http-response";


@Component({
  selector: 'app-step7',
  templateUrl: './step7.component.html',
  styleUrls: []
})
export class Step7Component implements OnInit {

  privateKey: string = "";

  innerId: number;

  addressKey: string;

  toAddress: string;

  signature: string = '';

  step: number = 7;

  balance: number;

  offeredMaxFee: number;

  /*
 CS 122 Generating public, private keys for wallets and signing transactions using EdDSA (Ed25519) algorithm in Wallet-Web
a library is used to generate keys https://github.com/dchest/tweetnacl-js

The required result is a signature signed with a secret key
The means to achieve the goal: Public and private key that was generated by the library
The message string collected from the parameters to generate the transaction
 */
  tweetnacl = require('tweetnacl');

  bufferToUint8array = require('buffer-to-uint8array');

  base58 = require('base-58');

  constructor(
    public dataService: DataService,
    private utils: Utils
  ) { }

  ngOnInit() {
    this.dataService.privateKeyObservable.subscribe(
      privateKey => {
        this.privateKey = privateKey;
      }
    );

    this.dataService.addressKeyObservable.subscribe(
      addressKey => {
        this.addressKey = addressKey
      }
    );

    this.dataService.toAddressObservable.subscribe(
      toAddress => {
        this.toAddress = toAddress
      }
    );

    this.dataService.refreshBalance(this.dataService.currencyCode); //update the balance

    this.innerId = Number(Date.now());

    var tranAmountInt = this.utils.parseInt(this.dataService.amountInCs);
    var tranAmountFrac = this.utils.parseFraction(this.dataService.amountInCs);
    var tranOfferedMaxFeeInt = this.utils.parseInt(this.dataService.offeredMaxFee);
    var tranOfferedMaxFeeFraction = this.utils.parseFraction(this.dataService.offeredMaxFee);
    var currencyCode = 1;
    var userFieldCount = 0;

    var buffer = this.utils.createTransactionBuffer(
      this.innerId,
      this.addressKey,
      this.toAddress,
      tranAmountInt,
      tranAmountFrac,
      tranOfferedMaxFeeInt,
      tranOfferedMaxFeeFraction,
      currencyCode,
      userFieldCount,
      null
    );


    let signedMessage = this.tweetnacl.sign.detached(this.bufferToUint8array(buffer), this.base58.decode(this.privateKey));

    this.signature = this.base58.encode(signedMessage);

    this.balance = this.dataService.accountData.balance;
  }

  @Output() changeStepEvent = new EventEmitter<number>();

  public goToStep(step : number) {

    if (step == 8) {
      this.dataService.generateTransaction(
        this.innerId,
        this.addressKey,
        this.toAddress,
        this.dataService.amountInCs,
        this.balance,
        this.dataService.currencyCode,
        this.signature,
        this.dataService.offeredMaxFee
      ).subscribe(
        data =>  {
          this.dataService.openDialogInfo("Transaction created successfully");
          this.dataService.prevStep = 6;
          this.changeStepEvent.emit(step);
        },
        err => {
          this.dataService.openDialogInfo(err.error.message);
        }
      );
    } else {
      this.dataService.prevStep = 6;
      this.changeStepEvent.emit(step);
    }
  }

  public goToPrevStep() {
    this.changeStepEvent.emit(this.dataService.prevStep);
  }
}


